#
# A theme inspired by sorin and nicoulaj and my old theme
#
# Authors:
#   Tobias Witt <tobias.witt@hhu.de>
#
# Features:
#   - Lambda Prompt Character (Half-Life 3 confirmed!!!)
#   - Two lines.
#   - VCS information in both prompts
#   - If in a repository: show only the repository dirname and its subpaths
#   - Crops the path to a defined length
#   - Has a last command success indicator
#   - Shows if logged in as root or not.
#
# Depends:
#   - prezto git module
#
# Screenshots:
#   https://www.dropbox.com/s/088v71s787dejfq/Screenshot%202014-07-12%2013.58.20.png
#

# turns seconds into human readable time
# 165392 => 1d 21h 56m 32s
# borrowed from sindresorhus/pure
prompt_ohcibi_human_time() {
  local tmp=$1
  local days=$(( tmp / 60 / 60 / 24 ))
  local hours=$(( tmp / 60 / 60 % 24 ))
  local minutes=$(( tmp / 60 % 60 ))
  local seconds=$(( tmp % 60 ))
  (( $days > 0 )) && echo -n "${days}d "
  (( $hours > 0 )) && echo -n "${hours}h "
  (( $minutes > 0 )) && echo -n "${minutes}m "
  echo "${seconds}s"
}

# displays the exec time of the last command if set threshold was exceeded
# borrowed from sindresorhus/pure
prompt_ohcibi_cmd_exec_time() {
  local timeout=5
  local stop=$EPOCHSECONDS
  local start=${cmd_timestamp:-$stop}
  integer elapsed=$stop-$start
  (($elapsed > ${PURE_CMD_MAX_EXEC_TIME:=$timeout})) && prompt_ohcibi_human_time $elapsed
}

function prompt_ohcibi_preexec {
  # borrowed from sindresorhus/pure
  cmd_timestamp=$EPOCHSECONDS
  cmd_executed=$2

  print -Pn "\e]0;"
  echo -nE "$PWD:t: $2"
  print -Pn "\a"
}

function is-discharging {
  pmset -g batt | fgrep -Fq "discharging"
}

function dir-info {
  typeset -gA dir_info

  typeset -AH dir_states
  zstyle -s ':prezto:module:prompt:ohcibi:dir:state:icons:default' format 'dir_states[DEFAULT]'
  zstyle -s ':prezto:module:prompt:ohcibi:dir:state:icons:home' format 'dir_states[HOME]'
  zstyle -s ':prezto:module:prompt:ohcibi:dir:state:icons:homesub' format 'dir_states[HOME_SUBFOLDER]'
  zstyle -s ':prezto:module:prompt:ohcibi:dir:state:icons:etc' format 'dir_states[ETC]'
  zstyle -s ':prezto:module:prompt:ohcibi:dir:state:icons:node' format 'dir_states[NODE]'
  zstyle -s ':prezto:module:prompt:ohcibi:dir:state:icons:git' format 'dir_states[GIT]'

  local state_path="$(print -P '%~')"
  local current_state="DEFAULT"
  if [[ $state_path == '/etc'* ]]; then
    current_state='ETC'
  elif [[ $state_path == *'node_modules'* ]]; then
    current_state='NODE'
  elif [[ -n $vcs_info_msg_1_ ]]; then
    current_state='GIT'
  elif [[ $state_path == '~' ]]; then
    current_state="HOME"
  elif [[ $state_path == '~'* ]]; then
    current_state="HOME_SUBFOLDER"
  fi

  local state=${dir_states[$current_state]}
  local state_format
  local state_formatted
  zstyle -s ':prezto:module:prompt:ohcibi:dir:state:state' format 'state_format'
  zformat -f state_formatted "$state_format" "s:$state"

  if [[ ! -w "$PWD" ]]; then
    local locked
    local locked_format
    local locked_formatted
    zstyle -s ':prezto:module:prompt:ohcibi:dir:state:icons:locked' format 'locked'
    zstyle -s ':prezto:module:prompt:ohcibi:dir:state:locked' format 'locked_format'
    zformat -f locked_formatted "$locked_format" "s:$locked"

    state_formatted="$locked_formatted $state_formatted"
  fi

  dir_info[state]=$state_formatted
}

function prompt_ohcibi_precmd {
  vcs_info
  git-info
  ruby-info
  python-info
  dir-info

  unset exec_time
  typeset -gA exec_time

  local elapsed
  local elapsed_format
  local elapsed_formatted

  elapsed="`prompt_ohcibi_cmd_exec_time`"
  if [[ -n $elapsed ]]; then
    local cmd_format
    local cmd_formatted
    zstyle -s ':prezto:module:exec_time:elapsed_format' format 'elapsed_format'
    zformat -f elapsed_formatted "$elapsed_format" "t:$elapsed"
    exec_time[elapsed]="$elapsed_formatted"

    zstyle -s ':prezto:module:exec_time:cmd_format' format 'cmd_format'
    zformat -f cmd_formatted "$cmd_format" "c:$cmd_executed"
    exec_time[cmd]="$cmd_formatted"
  fi

  # reset value since `preexec` isn't always triggered
  unset cmd_timestamp

  # battery state
  typeset -gA battery_info
  local perc=${$(battery-percentage)/\%/%%}
  local perc_value=`echo $perc | sed -e 's/%//g'`
  local batteryps
  if is-discharging || ! [ $perc_value = 100 ]; then
    batteryps="$perc"
  fi

  local c=(    # percentage colors
    "%F{160}"  # red
    "%F{166}"  # orange
    "%F{172}"  # dark yellow
    "%F{178}"  # yellow
    "%F{143}"  # yellow green
    "%F{034}"  # green
    "%F{112}") # light green

  local ic=(   # icon colors
    "%F{161}"  # red
    "%F{167}"  # orange
    "%F{173}"  # dark yellow
    "%F{179}"  # yellow
    "%F{142}"  # green
    "%F{040}"  # green
    "%F{112}") # light green

  # colortest:
  # batteryps="$batteryps ${c[1]}10%f ${c[2]}10%f ${c[3]}10%f ${c[4]}10%f ${c[5]}10%f ${c[6]}10%f ${c[7]}10%f ${ic[1]}%f ${ic[2]}%f ${ic[3]}%f ${ic[4]}%f ${ic[5]}%f ${ic[6]}%f ${ic[7]}%f"

  if is-discharging; then
    if [ $perc_value -lt 10 ]; then
      batteryps="${ic[1]}%f ${c[1]}${batteryps}%f"
    elif [ $perc_value -lt 20 ]; then
      batteryps="${ic[1]}%f ${c[1]}${batteryps}%f" # f579
    elif [ $perc_value -lt 30 ]; then
      batteryps="${ic[2]}%f ${c[2]}${batteryps}%f" # f57a
    elif [ $perc_value -lt 40 ]; then
      batteryps="${ic[2]}%f ${c[2]}${batteryps}%f" # f57b
    elif [ $perc_value -lt 50 ]; then
      batteryps="${ic[3]}%f ${c[3]}${batteryps}%f" # f57c
    elif [ $perc_value -lt 60 ]; then
      batteryps="${ic[3]}%f ${c[3]}${batteryps}%f" # f57d
    elif [ $perc_value -lt 70 ]; then
      batteryps="${ic[4]}%f ${c[4]}${batteryps}%f" # f57e
    elif [ $perc_value -lt 80 ]; then
      batteryps="${ic[5]}%f ${c[5]}${batteryps}%f" # f57f
    elif [ $perc_value -lt 90 ]; then
      batteryps="${ic[6]}%f ${c[6]}${batteryps}%f" # f580
    elif [ $perc_value -lt 100 ]; then
      batteryps="${ic[7]}%f ${c[7]}${batteryps}%f" # f581
    else
      batteryps="${ic[7]}%f ${c[7]}${batteryps}%f" # f578
    fi
  else
    if [ $perc_value -lt 30 ]; then
      batteryps="${ic[1]}%b%f ${c[1]}${batteryps}%f" # f585
    elif [ $perc_value -lt 40 ]; then
      batteryps="${ic[2]}%b%f ${c[2]}${batteryps}%f" # f586
    elif [ $perc_value -lt 60 ]; then
      batteryps="${ic[3]}%b%f ${c[3]}${batteryps}%f" # f587
    elif [ $perc_value -lt 80 ]; then
      batteryps="${ic[4]}%b%f ${c[4]}${batteryps}%f" # f588
    elif [ $perc_value -lt 90 ]; then
      batteryps="${ic[5]}%b%f ${c[5]}${batteryps}%f" # f589
    elif [ $perc_value -lt 100 ]; then
      batteryps="${ic[6]}%b%f ${c[6]}${batteryps}%f" # f58a
    else
      batteryps="${ic[7]}ﮣ%b%f"              # fba3
    fi
  fi

  battery_info[rprompt]=$batteryps

  unset node_info # hack: see arender callback
  unset weather_info
  typeset -gA weather_info
  async_job my_worker prompt_ohcibi_weather_check

  render_prompt
}

# weather
function prompt_ohcibi_weather_check() {
  local -A symbols=(
    Sunny "☀️ "
    "Clear" "☀️ "
    "Sunny" "☀️ "
    "Partly cloudy" "🌤 "
    "Cloudy" "☁️ "
    "Overcast" "🌥 "
    "Mist" "🌫 "
    "Patchy rain possible" "🌧 "
    "Fog" "🌫 "
    "Light drizzle" "🌧 "
    "Light Rain" "🌦 "
    "Light rain" "🌦 "
    "Light rain shower" "🌧 "
    "Rain Shower" "🌧 "
    # TODO:
    # "Patchy snow possible"
    # "Patchy sleet possible"
    # "Patchy freezing drizzle possible"
    # "Thundery outbreaks possible"
    # "Blowing snow"
    # "Blizzard"
    # "Freezing fog"
    # "Patchy light drizzle"
    # "Freezing drizzle"
    # "Heavy freezing drizzle"
    # "Patchy light rain"
    # "Moderate rain at times"
    # "Moderate rain"
    # "Heavy rain at times"
    # "Heavy rain"
    # "Light freezing rain"
    # "Moderate or heavy freezing rain"
    # "Light sleet"
    # "Moderate or heavy sleet"
    # "Patchy light snow"
    # "Light snow"
    # "Patchy moderate snow"
    # "Moderate snow"
    # "Patchy heavy snow"
    # "Heavy snow"
    # "Ice pellets"
    # "Moderate or heavy rain shower"
    # "Torrential rain shower"
    # "Light sleet showers"
    # "Moderate or heavy sleet showers"
    # "Light snow showers"
    # "Moderate or heavy snow showers"
    # "Patchy light rain with thunder"
    # "Moderate or heavy rain with thunder"
    # "Patchy light snow with thunder"
    # "Moderate or heavy snow with thunder"
  )

  local weatherstr
  weatherstr=$(curl -s wttr.in/Düsseldorf"?TQ0" | sed -n '1,2p' | cut -c 16-)
  weather=("${(f)weatherstr}")
  (( ${+symbols[$weather[1]]} )) && weather[1]=$symbols[$weather[1]]
  echo "$weather[1] $weather[2] $weather[3]"
}

function prompt_ohcibi_setup {
  # prevent percentage showing up
  # if output doesn't end with a newline
  # borrowed from sindresorhus/pure
  export PROMPT_EOL_MARK=''

  setopt LOCAL_OPTIONS
  unsetopt XTRACE KSH_ARRAYS
  prompt_opts=(cr percent subst)

  # Load required functions.
  zmodload zsh/datetime
  autoload -Uz add-zsh-hook
  autoload -Uz vcs_info

  autoload -Uz async && async
  async_start_worker my_worker -n

  arender() {
    case $1 in
      prompt_ohcibi_weather_check)
        weather_info[prompt]=$3
    esac
    [[ -n $6 ]] && return

    # hack: call node-info in this callback in order to make it a) async and b) inside the right environment
    # plus we need to load node properly by calling node once because nvm 👰
    (( $+commands[node] )) && node --version &> /dev/null && node-info

    render_prompt
    zle && zle .reset-prompt
  }

  async_register_callback my_worker arender

  add-zsh-hook precmd prompt_ohcibi_precmd
  add-zsh-hook preexec prompt_ohcibi_preexec

  # Customizable parameters.
  local path_color='%F{4}'
  local success_color='%F{071}'
  local failure_color='%F{124}'
  local vcs_info_color='%F{242}'
  local def_color='%F{3}'
  local user_color='%F{17}'
  local branch_color='%F{066}'
  local action_color='%F{23}'
  local commit_color='%F{23}'
  local host_color='%F{52}'
  local ruby_color='%F{099}'

  # Set vcs_info parameters.
  zstyle ':vcs_info:*' enable bzr git hg svn
  zstyle ':vcs_info:*' actionformats "%S" "%F{5}(${action_color}%a%F{5})%f ${path_color}%r/${path_color}"
  zstyle ':vcs_info:*' formats "%S" "${path_color}%r"
  zstyle ':vcs_info:*' nvcsformats "%~" ""

  zstyle ':prezto:module:editor:info:completing'                format '%B%F{red}...%f%b'
  zstyle ':prezto:module:editor:info:keymap:primary'            format "%B%(?;${success_color}✔;${failure_color}✗)%f%b"
  zstyle ':prezto:module:editor:info:keymap:alternate'          format '%F{166}☭%f'

  zstyle ':prezto:module:git:info' verbose 'yes'
  zstyle ':prezto:module:git:info:action'                       format ' %%B%F{yellow}%s%f%%b'
  zstyle ':prezto:module:git:info:added'                        format ' %%B%F{green}✚%f%%b'
  zstyle ':prezto:module:git:info:ahead'                        format ' %%B%F{blue}⇡%f%%b'
  zstyle ':prezto:module:git:info:behind'                       format ' %%B%F{green}⇣%f%%b'
  zstyle ':prezto:module:git:info:branch'                       format "${branch_color}%b%f"
  zstyle ':prezto:module:git:info:commit'                       format "${commit_color}%.7c%f"
  zstyle ':prezto:module:git:info:deleted'                      format ' %%B%F{red}✖%f%%b'
  zstyle ':prezto:module:git:info:modified'                     format ' %%B%F{blue}✱%f%%b'
  zstyle ':prezto:module:git:info:position'                     format '%F{red}%p%f'
  zstyle ':prezto:module:git:info:renamed'                      format ' %%B%F{magenta}➜%f%%b'
  zstyle ':prezto:module:git:info:stashed'                      format ' %%B%F{cyan}✭%f%%b'
  zstyle ':prezto:module:git:info:unmerged'                     format ' %%B%F{yellow}═%f%%b'
  zstyle ':prezto:module:git:info:untracked'                    format ' %%B%F{yellow}◼%f%%b'
  zstyle ':prezto:module:git:info:keys'                         format \
    'prompt' ' %p%b  %c' \
    'rprompt' '%A%B%S%s%a%d%m%r%U%u '

  zstyle ':prezto:module:ruby:info:version'                     format "%F{red}%f ${ruby_color}%v%f"

  zstyle ':prezto:module:exec_time:elapsed_format'              format "%F{yellow}%t%f"
  zstyle ':prezto:module:exec_time:cmd_format'                  format "%c"

  zstyle ':prezto:module:python:info:virtualenv'                format "%F{094}%v%f"

  zstyle ':prezto:module:node:info:version'                     format '%F{028}%f %F{070}%v%f'

  zstyle ':prezto:module:prompt:ohcibi:dir:state:state'         format '%F{015}%s%f'
  zstyle ':prezto:module:prompt:ohcibi:dir:state:locked'        format '%F{129}%s%f'
  zstyle ':prezto:module:prompt:ohcibi:dir:state:icons:default' format ''
  zstyle ':prezto:module:prompt:ohcibi:dir:state:icons:home'    format ''
  zstyle ':prezto:module:prompt:ohcibi:dir:state:icons:homesub' format ''
  zstyle ':prezto:module:prompt:ohcibi:dir:state:icons:etc'     format ''
  zstyle ':prezto:module:prompt:ohcibi:dir:state:icons:node'    format ''
  zstyle ':prezto:module:prompt:ohcibi:dir:state:icons:git'     format ''
  zstyle ':prezto:module:prompt:ohcibi:dir:state:icons:locked'  format ''
}

render_prompt() {
  local max_path_chars=30
  local user_char='λ'
  local root_char='G'
  local prompt_color='%F{9}'
  local path_color='%F{4}'
  # Define prompts.
  # note to self: if ever a string is needed in the prompt, define it in precmd instead of trying
  # to append it right here
  local -a preprompt_parts
  local -a prompt_parts

  if [[ -z $prompt_newline ]]; then
    # This variable needs to be set, usually set by promptinit.
    typeset -g prompt_newline=$'\n%{\r%}'
  fi

  preprompt_parts+=('${editor_info[keymap]}')
  path_string=$path_color'%B${vcs_info_msg_1_:+${vcs_info_msg_1_}/}%b'$path_color'%'$max_path_chars'<...<${vcs_info_msg_0_%%.}%<<%b%f'

  if [[ -n $vcs_info_msg_1_ ]]; then
    path_string="$path_string ${git_info[prompt]}"
  fi

  local -a info_string_parts
  local cc0=189
  local ccs=018
  local cc1=253
  local cc2=255

  info_string_parts+=("%K{$ccs}%F{$cc0}%f ${dir_info[state]} %K{$cc1}%F{$ccs}%f $path_string %F{$cc1}%K{$cc2}%f")

  [[ -n ${ruby_info[version]} ]]   && info_string_parts+=('${${ruby_info[version]}/-ruby/}')
  [[ -n ${node_info[version]} ]]   && info_string_parts+=('${node_info[version]}')

  preprompt_parts+=("${(j. .)info_string_parts} %F{$cc0}%f%k")

  [[ -n ${weather_info[prompt]} ]] && preprompt_parts+=('${weather_info[prompt]}')

  [[ -n ${exec_time[cmd]} ]] && prompt_parts+=('%20>...>${exec_time[cmd]}%<<')
  [[ -n ${exec_time[elapsed]} ]] && prompt_parts+=('${exec_time[elapsed]}')
  prompt_parts+=($prompt_color'%B%(!.'$root_char'.'$user_char')%f%b')

  local -ah ps1
  ps1=(
    $prompt_newline
    #'"'
    ${(j. .)preprompt_parts}
    #'"'
    $prompt_newline
    ${(j. .)prompt_parts}
  )
  PROMPT="${(j..)ps1} "

  local -a rprompt_parts
  [[ -n ${git_info[rprompt]} ]] && rprompt_parts+=('${git_info[rprompt]}')

  [[ -n ${python_info[virtualenv]} ]] && rprompt_parts+=('%F{darkgreen}%f %B${python_info[virtualenv]}%b')

  if [[ -n $ITERM_PROFILE && $ITERM_PROFILE = "Hotkey Window" ]]; then
    rprompt_parts+=(' %B%F{120}%*%f%b')
  else
    rprompt_parts+=(' %B%F{022}%*%f%b')
  fi

  [[ -n ${battery_info[rprompt]} ]]   && rprompt_parts+=('%B${battery_info[rprompt]}%b')

  RPROMPT="%K{$cc2}%F{$cc0}%f ${(j. .)rprompt_parts} %F{$cc0}%f%k"

  SPROMPT="zsh: correct %F{red}%R%f to %F{green}%r%f [nyae]? "
}

prompt_ohcibi_setup "$@"
